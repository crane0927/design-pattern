# 设计模式（Design Patterns）—— 23种设计模式完整整理

> **设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。**  
> 本项目包含 GoF（Gang of Four）提出的 23 种经典设计模式的完整实现和详细文档。

---

## 📚 目录

- [设计模式分类](#设计模式分类)
- [创建型模式（5种）](#创建型模式5种)
- [结构型模式（7种）](#结构型模式7种)
- [行为型模式（11种）](#行为型模式11种)
- [设计模式对比](#设计模式对比)
- [设计原则](#设计原则)
- [如何选择设计模式](#如何选择设计模式)
- [参考资源](#参考资源)

---

## 设计模式分类

设计模式按照目的和范围可以分为三类：

| 分类 | 数量 | 关注点 | 目录 |
|------|------|--------|------|
| **创建型模式** | 5种 | 对象的创建 | `creational/` |
| **结构型模式** | 7种 | 对象的结构和组合 | `structural/` |
| **行为型模式** | 11种 | 对象间的通信和职责分配 | `behavioral/` |

**总计：23种设计模式**

---

## 创建型模式（5种）

创建型模式关注对象的创建过程，将对象的创建与使用分离。

| 模式 | 目录 | 目的 | 典型场景 |
|------|------|------|---------|
| **单例模式** | `creational/singleton/` | 保证一个类只有一个实例 | 配置管理、线程池、连接池 |
| **工厂模式** | `creational/factory/` | 封装对象创建过程 | 需要创建多种类型对象 |
| **抽象工厂模式** | `creational/factory/abstract_factory/` | 创建一系列相关对象 | 产品族、跨平台UI |
| **建造者模式** | `creational/builder/` | 构建复杂对象 | 多参数对象构造 |
| **原型模式** | `creational/prototype/` | 通过克隆创建对象 | 对象创建成本高、需要大量相似对象 |

### 详细文档

- [创建型模式对比总结](../creational/README.md)
- [单例模式](../creational/singleton/README.md)
- [工厂模式](../creational/factory/README.md)
- [建造者模式](../creational/builder/README.md)
- [原型模式](../creational/prototype/README.md)

---

## 结构型模式（7种）

结构型模式关注对象的结构和组合，描述如何将类或对象组合在一起形成更大的结构。

| 模式 | 目录 | 目的 | 典型场景 |
|------|------|------|---------|
| **适配器模式** | `structural/adapter/` | 让不兼容的接口协同工作 | 接口转换、第三方库集成 |
| **桥接模式** | `structural/bridge/` | 将抽象与实现分离 | 多维度变化、平台无关 |
| **组合模式** | `structural/composite/` | 组合对象形成树形结构 | 树形结构、递归结构 |
| **装饰器模式** | `structural/decorator/` | 动态添加功能 | 功能扩展、流式处理 |
| **外观模式** | `structural/facade/` | 为子系统提供统一接口 | 简化接口、系统集成 |
| **享元模式** | `structural/flyweight/` | 共享细粒度对象 | 大量相似对象、内存优化 |
| **代理模式** | `structural/proxy/` | 为对象提供代理 | 访问控制、延迟加载、增强功能 |

### 详细文档

- [结构型模式对比总结](../structural/README.md)
- [适配器模式](../structural/adapter/README.md)
- [桥接模式](../structural/bridge/README.md)
- [组合模式](../structural/composite/README.md)
- [装饰器模式](../structural/decorator/README.md)
- [外观模式](../structural/facade/README.md)
- [享元模式](../structural/flyweight/README.md)
- [代理模式](../structural/proxy/README.md)

---

## 行为型模式（11种）

行为型模式关注对象间的通信和职责分配，描述对象之间如何协作完成单个对象无法完成的任务。

| 模式 | 目录 | 目的 | 典型场景 |
|------|------|------|---------|
| **责任链模式** | `behavioral/responsibility/` | 将请求沿着链传递 | 多级审批、过滤器链 |
| **命令模式** | `behavioral/command/` | 将请求封装成对象 | GUI操作、撤销/重做、事务处理 |
| **解释器模式** | `behavioral/interpreter/` | 解释语言的句子 | 简单文法、表达式计算、规则引擎 |
| **迭代器模式** | `behavioral/iterator/` | 遍历集合元素 | 统一遍历接口、解耦遍历逻辑 |
| **中介者模式** | `behavioral/mediator/` | 封装对象间的交互 | 复杂交互、降低耦合、集中控制 |
| **备忘录模式** | `behavioral/memento/` | 保存和恢复对象状态 | 撤销/重做、状态保存、快照功能 |
| **观察者模式** | `behavioral/observer/` | 定义对象间的一对多依赖关系 | 事件通知、发布-订阅、模型-视图分离 |
| **状态模式** | `behavioral/state/` | 封装状态，状态可以转换 | 状态依赖行为、状态转换、避免条件判断 |
| **策略模式** | `behavioral/strategy/` | 封装算法，使算法可替换 | 多种算法完成同一任务、算法可替换 |
| **模板方法模式** | `behavioral/template/` | 定义算法骨架，子类实现步骤 | 算法结构固定、步骤可变、代码复用 |
| **访问者模式** | `behavioral/visitor/` | 对元素执行操作 | 对象结构稳定、操作多变、操作分离 |

### 详细文档

- [行为型模式对比总结](../behavioral/README.md)
- [责任链模式](../behavioral/responsibility/README.md)
- [命令模式](../behavioral/command/README.md)
- [解释器模式](../behavioral/interpreter/README.md)
- [迭代器模式](../behavioral/iterator/README.md)
- [中介者模式](../behavioral/mediator/README.md)
- [备忘录模式](../behavioral/memento/README.md)
- [观察者模式](../behavioral/observer/README.md)
- [状态模式](../behavioral/state/README.md)
- [策略模式](../behavioral/strategy/README.md)
- [模板方法模式](../behavioral/template/README.md)
- [访问者模式](../behavioral/visitor/README.md)

---

## 设计模式对比

### 创建型 vs 结构型 vs 行为型

| 对比项 | 创建型模式 | 结构型模式 | 行为型模式 |
|--------|-----------|-----------|-----------|
| **关注点** | 对象的创建 | 对象的结构和组合 | 对象间的通信和职责分配 |
| **核心问题** | 如何创建对象 | 如何组合对象 | 如何协作对象 |
| **典型场景** | 对象创建复杂、需要控制实例 | 接口不兼容、需要组合 | 对象间需要通信、算法需要封装 |
| **设计原则** | 单一职责、开闭原则 | 组合优于继承、接口隔离 | 依赖倒置、迪米特法则 |


---

## 设计原则

设计模式遵循以下设计原则：

### SOLID 原则

1. **单一职责原则（SRP）**
   - 一个类应该只有一个引起它变化的原因
   - 每个模式都有明确的职责

2. **开闭原则（OCP）**
   - 对扩展开放，对修改关闭
   - 添加新功能时尽量不修改现有代码

3. **里氏替换原则（LSP）**
   - 子类对象可以替换父类对象
   - 保证继承关系的正确性

4. **接口隔离原则（ISP）**
   - 客户端不应该依赖它不需要的接口
   - 接口应该小而专一

5. **依赖倒置原则（DIP）**
   - 依赖抽象，不依赖具体实现
   - 使用接口和抽象类

### 其他重要原则

- **组合优于继承**：优先使用组合而不是继承
- **迪米特法则**：对象之间应该尽量少了解
- **DRY 原则**：不要重复自己（Don't Repeat Yourself）
- **KISS 原则**：保持简单（Keep It Simple, Stupid）

---

## 如何选择设计模式

### 1. 根据问题类型选择

**问题：对象创建复杂**
- 需要控制实例数量 → 单例模式
- 需要创建多种类型对象 → 工厂模式
- 需要构建复杂对象 → 建造者模式
- 需要复制对象 → 原型模式

**问题：对象结构需要调整**
- 接口不兼容 → 适配器模式
- 需要分离抽象和实现 → 桥接模式
- 需要树形结构 → 组合模式
- 需要动态添加功能 → 装饰器模式
- 需要简化接口 → 外观模式
- 需要共享对象 → 享元模式
- 需要控制访问 → 代理模式

**问题：对象间需要协作**
- 需要一对多通知 → 观察者模式
- 需要多对多交互 → 中介者模式
- 需要请求传递 → 责任链模式
- 需要封装算法 → 策略模式
- 需要定义算法骨架 → 模板方法模式
- 需要封装请求 → 命令模式
- 需要管理状态 → 状态模式
- 需要保存状态 → 备忘录模式
- 需要遍历集合 → 迭代器模式
- 需要访问元素 → 访问者模式
- 需要解释语言 → 解释器模式

### 2. 根据设计原则选择

**需要解耦**
- 对象间解耦 → 观察者模式、中介者模式、责任链模式
- 算法解耦 → 策略模式、命令模式
- 操作解耦 → 访问者模式

**需要扩展性**
- 添加新算法 → 策略模式
- 添加新操作 → 访问者模式
- 添加新状态 → 状态模式
- 添加新表达式 → 解释器模式

**需要代码复用**
- 算法复用 → 模板方法模式
- 遍历复用 → 迭代器模式

### 3. 避免过度设计

- **简单问题用简单方法**：不要为了使用模式而使用模式
- **根据实际需求选择**：根据具体问题选择合适的模式
- **保持代码简洁**：保持代码的可读性和可维护性
- **考虑性能影响**：注意模式的性能影响

---

## 设计模式速查表

### 创建型模式（5种）

| 模式 | 一句话总结 | 使用频率 |
|------|-----------|---------|
| 单例模式 | 保证一个类只有一个实例 | ⭐⭐⭐⭐⭐ |
| 工厂模式 | 封装对象创建过程 | ⭐⭐⭐⭐⭐ |
| 抽象工厂模式 | 创建一系列相关对象 | ⭐⭐⭐⭐ |
| 建造者模式 | 构建复杂对象 | ⭐⭐⭐⭐ |
| 原型模式 | 通过克隆创建对象 | ⭐⭐⭐ |

### 结构型模式（7种）

| 模式 | 一句话总结 | 使用频率 |
|------|-----------|---------|
| 适配器模式 | 让不兼容的接口协同工作 | ⭐⭐⭐⭐ |
| 桥接模式 | 将抽象与实现分离 | ⭐⭐⭐ |
| 组合模式 | 组合对象形成树形结构 | ⭐⭐⭐⭐ |
| 装饰器模式 | 动态添加功能 | ⭐⭐⭐⭐ |
| 外观模式 | 为子系统提供统一接口 | ⭐⭐⭐⭐ |
| 享元模式 | 共享细粒度对象 | ⭐⭐⭐ |
| 代理模式 | 为对象提供代理 | ⭐⭐⭐⭐⭐ |

### 行为型模式（11种）

| 模式 | 一句话总结 | 使用频率 |
|------|-----------|---------|
| 责任链模式 | 将请求沿着链传递 | ⭐⭐⭐ |
| 命令模式 | 将请求封装成对象 | ⭐⭐⭐⭐ |
| 解释器模式 | 解释语言的句子 | ⭐⭐ |
| 迭代器模式 | 遍历集合元素 | ⭐⭐⭐⭐⭐ |
| 中介者模式 | 封装对象间的交互 | ⭐⭐⭐ |
| 备忘录模式 | 保存和恢复对象状态 | ⭐⭐⭐ |
| 观察者模式 | 定义对象间的一对多依赖关系 | ⭐⭐⭐⭐⭐ |
| 状态模式 | 封装状态，状态可以转换 | ⭐⭐⭐⭐ |
| 策略模式 | 封装算法，使算法可替换 | ⭐⭐⭐⭐⭐ |
| 模板方法模式 | 定义算法骨架，子类实现步骤 | ⭐⭐⭐⭐ |
| 访问者模式 | 对元素执行操作 | ⭐⭐⭐ |

**使用频率说明：**
- ⭐⭐⭐⭐⭐：非常常用
- ⭐⭐⭐⭐：常用
- ⭐⭐⭐：一般
- ⭐⭐：较少使用

---

## 项目结构

```
com.example/
├── creational/          # 创建型模式（5种）
│   ├── singleton/      # 单例模式
│   ├── factory/        # 工厂模式
│   ├── builder/        # 建造者模式
│   └── prototype/       # 原型模式
├── structural/         # 结构型模式（7种）
│   ├── adapter/        # 适配器模式
│   ├── bridge/         # 桥接模式
│   ├── composite/      # 组合模式
│   ├── decorator/      # 装饰器模式
│   ├── facade/         # 外观模式
│   ├── flyweight/      # 享元模式
│   └── proxy/          # 代理模式
└── behavioral/         # 行为型模式（11种）
    ├── command/        # 命令模式
    ├── interpreter/    # 解释器模式
    ├── iterator/       # 迭代器模式
    ├── mediator/       # 中介者模式
    ├── memento/        # 备忘录模式
    ├── observer/       # 观察者模式
    ├── responsibility/ # 责任链模式
    ├── state/          # 状态模式
    ├── strategy/       # 策略模式
    ├── template/       # 模板方法模式
    └── visitor/        # 访问者模式
```

---

## 学习路径建议

### 初学者路径

1. **创建型模式**（从简单到复杂）
   - 单例模式 → 工厂模式 → 建造者模式 → 原型模式

2. **结构型模式**（从常用到不常用）
   - 适配器模式 → 装饰器模式 → 代理模式 → 外观模式 → 组合模式 → 桥接模式 → 享元模式

3. **行为型模式**（从常用到不常用）
   - 观察者模式 → 策略模式 → 模板方法模式 → 命令模式 → 状态模式 → 迭代器模式 → 责任链模式 → 中介者模式 → 备忘录模式 → 访问者模式 → 解释器模式

### 进阶路径

1. **理解设计原则**
   - SOLID 原则
   - 组合优于继承
   - 迪米特法则

2. **模式对比和选择**
   - 相似模式的对比
   - 模式的选择指南
   - 模式的组合使用

3. **实际应用**
   - 框架中的应用
   - 项目中的应用
   - 最佳实践

---

## 参考资源

### 经典书籍

- [设计模式：可复用面向对象软件的基础](https://book.douban.com/subject/1052241/)（GoF 经典著作）
- [Head First 设计模式](https://book.douban.com/subject/2243615/)（入门推荐）
- [设计模式解析](https://book.douban.com/subject/1232019/)（深入理解）

### 在线资源

- [设计模式 - Wikipedia](https://en.wikipedia.org/wiki/Design_pattern)
- [Refactoring Guru - 设计模式](https://refactoring.guru/design-patterns)
- [设计模式 - 菜鸟教程](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)

### 相关文档

- [创建型模式对比总结](../creational/README.md)
- [结构型模式对比总结](../structural/README.md)
- [行为型模式对比总结](../behavioral/README.md)

---

## 总结

设计模式是软件设计中的最佳实践，掌握设计模式可以帮助我们：

1. **提高代码质量**：编写更优雅、可维护的代码
2. **提高开发效率**：复用成熟的设计方案
3. **提高团队协作**：使用统一的设计语言
4. **提高系统设计能力**：理解复杂系统的设计思路

**记住：设计模式是工具，不是目标。根据实际需求选择合适的模式，避免过度设计。**

---

**本项目包含 23 种设计模式的完整实现和详细文档，每个模式都包含：**
- ✅ 完整的代码实现
- ✅ 详细的 README 文档
- ✅ UML 类图
- ✅ 使用示例
- ✅ 模式对比
- ✅ 最佳实践

**开始学习设计模式，提升你的代码设计能力！** 🚀
