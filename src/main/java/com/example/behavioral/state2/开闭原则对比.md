# 状态模式与开闭原则

## 问题：在两个状态之间插入新状态

### 场景
假设要在 `PaidState`（已支付）和 `ShippedState`（已发货）之间插入一个新状态 `ProcessingState`（处理中）。

---

## 方案1：原版实现（状态转换在状态类中）

### 需要修改的代码

**❌ 需要修改 `PaidState.java`：**
```java
// 修改前
context.transitionTo(new ShippedState());

// 修改后
context.transitionTo(new ProcessingState());
```

**✅ 需要创建 `ProcessingState.java`：**
```java
public class ProcessingState implements OrderState {
    @Override
    public void handle(OrderContext context) {
        System.out.println("处理中状态");
        context.transitionTo(new ShippedState());
        context.handle();
    }
}
```

### 问题
- ❌ **违反开闭原则**：需要修改现有代码（`PaidState.java`）
- ❌ **耦合度高**：状态类之间直接依赖
- ❌ **难以维护**：状态转换逻辑分散在各个状态类中

---

## 方案2：改进实现（使用状态转换管理器）

### 需要修改的代码

**✅ 只需要修改 `StateTransitionManager.java`：**
```java
// 在初始化时添加转换规则
TRANSITION_MAP.put(PaidState.class, ProcessingState.class);
TRANSITION_MAP.put(ProcessingState.class, ShippedState.class);
```

**✅ 或者动态添加（无需修改现有代码）：**
```java
StateTransitionManager.addTransition(PaidState.class, ProcessingState.class);
StateTransitionManager.addTransition(ProcessingState.class, ShippedState.class);
```

**✅ 需要创建 `ProcessingState.java`：**
```java
public class ProcessingState implements OrderState {
    @Override
    public void handle(OrderContext context) {
        System.out.println("处理中状态");
        OrderState nextState = StateTransitionManager.getNextState(this.getClass());
        if (nextState != null) {
            context.transitionTo(nextState);
            context.handle();
        }
    }
}
```

### 优势
- ✅ **符合开闭原则**：无需修改现有状态类
- ✅ **解耦**：状态类之间不直接依赖
- ✅ **集中管理**：状态转换逻辑集中在管理器中
- ✅ **易于扩展**：添加新状态只需修改转换表

---

## 对比总结

| 对比项 | 方案1（原版实现） | 方案2（状态转换管理器） |
|--------|------------------|----------------------|
| **开闭原则** | ❌ 违反（需修改现有代码） | ✅ 符合（只需修改转换表） |
| **耦合度** | ❌ 高（状态类直接依赖） | ✅ 低（通过管理器解耦） |
| **可维护性** | ❌ 低（逻辑分散） | ✅ 高（逻辑集中） |
| **扩展性** | ❌ 差（需修改多个类） | ✅ 好（只需修改转换表） |
| **复杂度** | ✅ 低（简单直接） | ❌ 高（需要管理器） |
| **性能** | ✅ 好（直接调用） | ⚠️ 略差（需要查找转换表） |

---

## 建议

### 使用方案1（原版实现）的场景：
- 状态转换逻辑简单
- 状态数量少
- 状态转换规则稳定，不会频繁变化
- 对性能要求高

### 使用方案2（状态转换管理器）的场景：
- 状态转换逻辑复杂
- 状态数量多
- 状态转换规则可能频繁变化
- 需要动态调整状态转换
- 需要严格遵循开闭原则

---

## 实际应用建议

1. **小型项目**：使用方案1，简单直接
2. **大型项目**：使用方案2，便于维护和扩展
3. **状态机框架**：使用方案2，提供更好的灵活性

---

## 总结

**原版实现确实违反了开闭原则**，但这是状态模式的一个常见权衡：

- **简单性 vs 灵活性**：原版实现简单，但扩展时需要修改代码
- **性能 vs 可维护性**：原版实现性能好，但可维护性较差

**改进方案（状态转换管理器）**通过引入额外的抽象层，解决了开闭原则的问题，但增加了复杂度。在实际项目中，应该根据具体需求选择合适的方案。
